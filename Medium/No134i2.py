class Solution(object):
    def canCompleteCircuit(self, gas, cost):
        """
        :type gas: List[int]
        :type cost: List[int]
        :rtype: int
        """
        """
        方法二：
        在题解里面看到一个特别有意思的解法，忍不住想实现一下，当然了，官方给的解法更精炼简洁些，但是很难自己想到，我这里实现的这个比较容易想到，而且很有意思
        1.假设从0点出发，遍历一遍，计算通过各个点时汽油剩余值（这里假设可以为负）gasSurplus[i] = ∑(gas[i]-cost[i])
        2.遍历完成后，当gasSurplus[-1]<0时，即完成一圈的汽油为负值，无法到达，返回-1
        3.为便于理解，可以将gasSurplus中各点画成折线图，我们发现，改变出发点时，这个折线形状不会发生大的改变（实际上，会有拼接的要素）
        4.因为从1点出发，相当于把水平方向的x轴上下平移，而使得i=1的上一个点变为0
        5.那么，实际上，若要满足能够跑完一圈，则需要gasSurplus在各个点都不为负，我们上下移动这个折线，使得最低点落在x轴上，则全程gasSurplus不会为负，则落到x轴上也就是使得gasSurplus为0的这个点的下一个点就是出发点，返回这个点索引，注意边界条件
        """
        gasSurplus = 0  # 记录当前剩余油量
        minSurplus = float('inf')   # 记录剩余油量最小值
        indexMin = -1   # 记录剩余油量最小时的索引值
        # 从0点出发，计算各个点的剩余油量值
        for i in range(len(gas)):
            gasSurplus += gas[i] - cost[i]
            # 当比最小值小时，更新最小值（相等时也更新）
            if gasSurplus <= minSurplus:
                minSurplus = gasSurplus
                indexMin = i
        # 跑完一圈后，剩余油量若为负，则意味着一圈的总消耗大于总补给，不可能跑完一圈
        if gasSurplus < 0:
            return -1
        return (indexMin+1)%len(gas)    # 为最后一个点时，最后一个点的下一个点应该为第一个点

"""
附上我在评论区与其他人的讨论
很棒的想法，其实我也想过画这个折线图，但是没能继续往下想。有很多朋友没有看懂，帮大家解释一下吧。 没看懂的基本都在说这个观点
index=3，从第三个点出发，gas[ 2 ] = 3, cost [ 2 ] = 5，显然错误
实际上是没能理解答主图中各个点的含义，尤其是索引号的含义。首先整张图是从0点（i=0,即第一个站）出发的到达各个点时剩余油量图，X轴对应的是到达的各个点。i=0对应的是第一个站，即gas[0]这个站，刚到时即没有加油也没有耗油，为0；i=1对应的是第二个站，即gas[1]这个站，刚到时，经历了0+gas[0]-cost[0]，此时剩余的油量为-2；...实际上
index=3，对应的是第四个站，也就是从第四个站出发，gas[ 3 ] = 4, cost [ 3 ] = 1，这不就起步成功了？
再来帮大家理解一下答主的思路，答主这个图是从0点（i=0,即第一个站）出发的折线图，那么改变出发点时，这个图会怎么变化呢？你可以自己去画一画，你会发现，整体折线图的形状是没有变的，改变的是y值，相当于将折线图在Y轴方向上上下平移。那么，当最小点落在X轴上时（也就是使得最小点y=0时），整体折线在X轴上方，y值恒大于等于0，也就是剩余油量一直不为负，可以绕行一圈。对于本例，也就是使得i=3时，y=0。此时，意味着从i=3，第四个站出发，到此站时即没有加油也没有耗油，剩余油量为0。 最后，希望大家遇到分歧时不要急着去否定对方，要多想，我只能告诉你，在那之前，要多想。
再来说下为什么代码里面，返回的是 indexMin+1 ，因为这里的索引值与图解里并不是一样的，图解是为了更好地去讲解思路，而代码中的索引是为了代码服务的，两个索引值并不对应。你可以发现，代码中，每次更新i的时候，剩余油量已经更新到下一个点了。例如i=0时，循环中的剩余油量 gasSurplus += gas[0] - cost[0]实际上是到达第二个点的剩余油量。这导致了最小值与索引值不匹配（差一位），所以输出时输出的是indexMin+1。 至于%len(gas)是为了处理超出索引的情况，其实就是落在最后一点时， indexMin+1取第一个点。
"""